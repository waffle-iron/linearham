<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>linearham: linearham Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">linearham
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">linearham Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlinearham_1_1DGermline.html">DGermline</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An abstraction used to represent a D germline gene.  <a href="classlinearham_1_1DGermline.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlinearham_1_1Germline.html">Germline</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The HMM representation of a germline gene, without reference to any reads.  <a href="classlinearham_1_1Germline.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlinearham_1_1JGermline.html">JGermline</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An abstraction used to represent a J germline gene.  <a href="classlinearham_1_1JGermline.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlinearham_1_1NPadding.html">NPadding</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An abstraction used to represent the padded germline states on the left (right) of V (J) genes.  <a href="classlinearham_1_1NPadding.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlinearham_1_1NTInsertion.html">NTInsertion</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An abstraction used to represent the non-templated insertion (NTI) regions.  <a href="classlinearham_1_1NTInsertion.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlinearham_1_1Smooshable.html">Smooshable</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstracts something that has probabilities associated with sequence start and stop points.  <a href="classlinearham_1_1Smooshable.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlinearham_1_1SmooshableChain.html">SmooshableChain</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An ordered list of smooshables that have been smooshed together, with associated information.  <a href="classlinearham_1_1SmooshableChain.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlinearham_1_1SmooshableGermline.html">SmooshableGermline</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A smooshable derived from a read aligned to a segment of germline gene.  <a href="classlinearham_1_1SmooshableGermline.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classlinearham_1_1VGermline.html">VGermline</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An abstraction used to represent a V germline gene.  <a href="classlinearham_1_1VGermline.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:afb6b8dc499c881b5d0cfe01ec2dba5b6"><td class="memItemLeft" align="right" valign="top">typedef std::vector&lt; <a class="el" href="classlinearham_1_1Smooshable.html">Smooshable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelinearham.html#afb6b8dc499c881b5d0cfe01ec2dba5b6">SmooshableVector</a></td></tr>
<tr class="separator:afb6b8dc499c881b5d0cfe01ec2dba5b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c03bd166d38e0e2343f658bd1c61d83"><td class="memItemLeft" align="right" valign="top">typedef std::vector<br class="typebreak" />
&lt; Eigen::MatrixXi &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelinearham.html#a6c03bd166d38e0e2343f658bd1c61d83">IntMatrixVector</a></td></tr>
<tr class="separator:a6c03bd166d38e0e2343f658bd1c61d83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fa79b0da5c8b25e196d6d382f95a01e"><td class="memItemLeft" align="right" valign="top">typedef std::vector<br class="typebreak" />
&lt; std::vector&lt; int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelinearham.html#a2fa79b0da5c8b25e196d6d382f95a01e">IntVectorVector</a></td></tr>
<tr class="separator:a2fa79b0da5c8b25e196d6d382f95a01e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a3c3ff26efcf3e4eea2c9f2cf89dafabe"><td class="memItemLeft" align="right" valign="top">Eigen::MatrixXd&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelinearham.html#a3c3ff26efcf3e4eea2c9f2cf89dafabe">BuildTransition</a> (Eigen::VectorXd &amp;landing, Eigen::VectorXd &amp;next_transition)</td></tr>
<tr class="memdesc:a3c3ff26efcf3e4eea2c9f2cf89dafabe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a transition probability matrix.  <a href="#a3c3ff26efcf3e4eea2c9f2cf89dafabe">More...</a><br /></td></tr>
<tr class="separator:a3c3ff26efcf3e4eea2c9f2cf89dafabe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bbd502136696449ea441fa266cdadf3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelinearham.html#a1bbd502136696449ea441fa266cdadf3">BuildMatchMatrix</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; transition, Eigen::VectorXd &amp;emission, Eigen::Ref&lt; Eigen::MatrixXd &gt; match)</td></tr>
<tr class="memdesc:a1bbd502136696449ea441fa266cdadf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a matrix with the probabilities of linear matches.  <a href="#a1bbd502136696449ea441fa266cdadf3">More...</a><br /></td></tr>
<tr class="separator:a1bbd502136696449ea441fa266cdadf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e16bc80240580a9eb7190baaf384427"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelinearham.html#a6e16bc80240580a9eb7190baaf384427">ColVecMatCwise</a> (const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;b, const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;A, Eigen::Ref&lt; Eigen::MatrixXd &gt; B)</td></tr>
<tr class="memdesc:a6e16bc80240580a9eb7190baaf384427"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes the coefficient-wise product of b and every column of A.  <a href="#a6e16bc80240580a9eb7190baaf384427">More...</a><br /></td></tr>
<tr class="separator:a6e16bc80240580a9eb7190baaf384427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37d0ddb7c5498902f53fc09dc01b6881"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelinearham.html#a37d0ddb7c5498902f53fc09dc01b6881">RowVecMatCwise</a> (const Eigen::Ref&lt; const Eigen::RowVectorXd &gt; &amp;b, const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;A, Eigen::Ref&lt; Eigen::MatrixXd &gt; B)</td></tr>
<tr class="memdesc:a37d0ddb7c5498902f53fc09dc01b6881"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes the coefficient-wise product of b and every row of A.  <a href="#a37d0ddb7c5498902f53fc09dc01b6881">More...</a><br /></td></tr>
<tr class="separator:a37d0ddb7c5498902f53fc09dc01b6881"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c1076d41d74aaa27dc93073ea10297e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelinearham.html#a6c1076d41d74aaa27dc93073ea10297e">SubProductMatrix</a> (const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;e, Eigen::Ref&lt; Eigen::MatrixXd &gt; A)</td></tr>
<tr class="memdesc:a6c1076d41d74aaa27dc93073ea10297e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function builds a matrix of sub-products.  <a href="#a6c1076d41d74aaa27dc93073ea10297e">More...</a><br /></td></tr>
<tr class="separator:a6c1076d41d74aaa27dc93073ea10297e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab09d0b9aa0bbaed826474a8fc1d94092"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelinearham.html#ab09d0b9aa0bbaed826474a8fc1d94092">VectorByIndices</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;A, const Eigen::Ref&lt; const Eigen::VectorXi &gt; &amp;a, Eigen::Ref&lt; Eigen::VectorXd &gt; b)</td></tr>
<tr class="memdesc:ab09d0b9aa0bbaed826474a8fc1d94092"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function extracts a vector of entries of a matrix by row index.  <a href="#ab09d0b9aa0bbaed826474a8fc1d94092">More...</a><br /></td></tr>
<tr class="separator:ab09d0b9aa0bbaed826474a8fc1d94092"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92a6afbc49a2dc32055289890ac6a68c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelinearham.html#a92a6afbc49a2dc32055289890ac6a68c">BinaryMax</a> (const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;A, const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;B, Eigen::Ref&lt; Eigen::MatrixXd &gt; C, Eigen::Ref&lt; Eigen::MatrixXi &gt; C_idx)</td></tr>
<tr class="memdesc:a92a6afbc49a2dc32055289890ac6a68c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function extracts a vector of entries of a matrix by row index.  <a href="#a92a6afbc49a2dc32055289890ac6a68c">More...</a><br /></td></tr>
<tr class="separator:a92a6afbc49a2dc32055289890ac6a68c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56af488fc596ebb21cfa851f01469e5e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelinearham.html#a56af488fc596ebb21cfa851f01469e5e">ScaleMatrix</a> (Eigen::Ref&lt; Eigen::MatrixXd &gt; m)</td></tr>
<tr class="memdesc:a56af488fc596ebb21cfa851f01469e5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales a matrix by SCALE_FACTOR as many times as needed to bring at least one entry of the matrix above SCALE_THRESHOLD.  <a href="#a56af488fc596ebb21cfa851f01469e5e">More...</a><br /></td></tr>
<tr class="separator:a56af488fc596ebb21cfa851f01469e5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b18787b2d615417a6b238bffd030998"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classlinearham_1_1Smooshable.html">Smooshable</a>, <br class="typebreak" />
Eigen::MatrixXi &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelinearham.html#a0b18787b2d615417a6b238bffd030998">Smoosh</a> (const <a class="el" href="classlinearham_1_1Smooshable.html">Smooshable</a> &amp;s_a, const <a class="el" href="classlinearham_1_1Smooshable.html">Smooshable</a> &amp;s_b)</td></tr>
<tr class="memdesc:a0b18787b2d615417a6b238bffd030998"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smoosh two smooshables!  <a href="#a0b18787b2d615417a6b238bffd030998">More...</a><br /></td></tr>
<tr class="separator:a0b18787b2d615417a6b238bffd030998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a201f64bb15d6550afe76ec91bdd33fc3"><td class="memItemLeft" align="right" valign="top">YAML::Node&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelinearham.html#a201f64bb15d6550afe76ec91bdd33fc3">get_yaml_root</a> (std::string yaml_path)</td></tr>
<tr class="memdesc:a201f64bb15d6550afe76ec91bdd33fc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the root node from a YAML file.  <a href="#a201f64bb15d6550afe76ec91bdd33fc3">More...</a><br /></td></tr>
<tr class="separator:a201f64bb15d6550afe76ec91bdd33fc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7c3811ec2172f192ecd27e98d4c063d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelinearham.html#ae7c3811ec2172f192ecd27e98d4c063d">is_equal_string_vecs</a> (std::vector&lt; std::string &gt; vec1, std::vector&lt; std::string &gt; vec2)</td></tr>
<tr class="memdesc:ae7c3811ec2172f192ecd27e98d4c063d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do two string vectors contain the same elements?  <a href="#ae7c3811ec2172f192ecd27e98d4c063d">More...</a><br /></td></tr>
<tr class="separator:ae7c3811ec2172f192ecd27e98d4c063d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac49a32ee78052d4f748f7082f5001002"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector<br class="typebreak" />
&lt; std::string &gt;<br class="typebreak" />
, Eigen::VectorXd &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelinearham.html#ac49a32ee78052d4f748f7082f5001002">parse_string_prob_map</a> (YAML::Node node)</td></tr>
<tr class="memdesc:ac49a32ee78052d4f748f7082f5001002"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a YAML map from strings to probabilities.  <a href="#ac49a32ee78052d4f748f7082f5001002">More...</a><br /></td></tr>
<tr class="separator:ac49a32ee78052d4f748f7082f5001002"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c0df111a675196fe2673a50a97c647a"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::vector<br class="typebreak" />
&lt; std::string &gt;<br class="typebreak" />
, std::unordered_map<br class="typebreak" />
&lt; std::string, int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelinearham.html#a0c0df111a675196fe2673a50a97c647a">get_alphabet</a> (YAML::Node root)</td></tr>
<tr class="memdesc:a0c0df111a675196fe2673a50a97c647a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the alphabet and alphabet-map from a YAML file.  <a href="#a0c0df111a675196fe2673a50a97c647a">More...</a><br /></td></tr>
<tr class="separator:a0c0df111a675196fe2673a50a97c647a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3808899cb2db8a3a231a11ec1459b249"><td class="memItemLeft" align="right" valign="top">std::pair&lt; std::regex, std::regex &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelinearham.html#a3808899cb2db8a3a231a11ec1459b249">get_regex</a> (std::string gname, std::vector&lt; std::string &gt; alphabet)</td></tr>
<tr class="memdesc:a3808899cb2db8a3a231a11ec1459b249"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the regex's that extract germline and insertion state labels.  <a href="#a3808899cb2db8a3a231a11ec1459b249">More...</a><br /></td></tr>
<tr class="separator:a3808899cb2db8a3a231a11ec1459b249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46be2fbc9551af01ae8b63b32f8347c3"><td class="memItemLeft" align="right" valign="top">std::pair&lt; int, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelinearham.html#a46be2fbc9551af01ae8b63b32f8347c3">find_germline_start_end</a> (YAML::Node root, std::string gname)</td></tr>
<tr class="memdesc:a46be2fbc9551af01ae8b63b32f8347c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the indices corresponding to the start and end of the germline gene.  <a href="#a46be2fbc9551af01ae8b63b32f8347c3">More...</a><br /></td></tr>
<tr class="separator:a46be2fbc9551af01ae8b63b32f8347c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a732264e6fba99037c44f896402b46f2b"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelinearham.html#a732264e6fba99037c44f896402b46f2b">SCALE_FACTOR</a> = pow(2, 256)</td></tr>
<tr class="separator:a732264e6fba99037c44f896402b46f2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a446f9faab6c4997544bb7e650e1d81"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelinearham.html#a7a446f9faab6c4997544bb7e650e1d81">SCALE_THRESHOLD</a> = (1.0 / <a class="el" href="namespacelinearham.html#a732264e6fba99037c44f896402b46f2b">SCALE_FACTOR</a>)</td></tr>
<tr class="separator:a7a446f9faab6c4997544bb7e650e1d81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a016030d1b11ad4876239174c980caccf"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacelinearham.html#a016030d1b11ad4876239174c980caccf">EPS_PARSE</a> = 1e-5</td></tr>
<tr class="separator:a016030d1b11ad4876239174c980caccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a6c03bd166d38e0e2343f658bd1c61d83"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;Eigen::MatrixXi&gt; <a class="el" href="namespacelinearham.html#a6c03bd166d38e0e2343f658bd1c61d83">linearham::IntMatrixVector</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a2fa79b0da5c8b25e196d6d382f95a01e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;std::vector&lt;int&gt; &gt; <a class="el" href="namespacelinearham.html#a2fa79b0da5c8b25e196d6d382f95a01e">linearham::IntVectorVector</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="afb6b8dc499c881b5d0cfe01ec2dba5b6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt;<a class="el" href="classlinearham_1_1Smooshable.html">Smooshable</a>&gt; <a class="el" href="namespacelinearham.html#afb6b8dc499c881b5d0cfe01ec2dba5b6">linearham::SmooshableVector</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a92a6afbc49a2dc32055289890ac6a68c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void linearham::BinaryMax </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Ref&lt; Eigen::MatrixXd &gt;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Ref&lt; Eigen::MatrixXi &gt;&#160;</td>
          <td class="paramname"><em>C_idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function extracts a vector of entries of a matrix by row index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>Input matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">B</td><td>Input matrix. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">C</td><td>Output matrix containing the matrix product maximum. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">C_idx</td><td>Output matrix containing the matrix product argmax. <code>idx</code> is short for "index".</td></tr>
  </table>
  </dd>
</dl>
<p>Assume \(A\) and \(B\) are matrices with compatible dimensions to form the product \(AB\). Then </p><p class="formulaDsp">
\[ C_{i,k} := \max_j A_{i,j} B_{j,k} \]
</p>
<p> and <code>C_idx</code> is the corresponding argmax. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000002">Todo:</a></b></dt><dd>Make faster by doing matrix-wise rather than vector-wise product. </dd></dl>

</div>
</div>
<a class="anchor" id="a1bbd502136696449ea441fa266cdadf3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void linearham::BuildMatchMatrix </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt;&#160;</td>
          <td class="paramname"><em>transition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>emission</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Ref&lt; Eigen::MatrixXd &gt;&#160;</td>
          <td class="paramname"><em>match</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds a matrix with the probabilities of linear matches. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">transition</td><td>Transition matrix from BuildTransition. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">emission</td><td>Vector of emission probabilities for a given read. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">match</td><td>Matrix of matches of various length. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3c3ff26efcf3e4eea2c9f2cf89dafabe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Eigen::MatrixXd linearham::BuildTransition </td>
          <td>(</td>
          <td class="paramtype">Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>landing</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::VectorXd &amp;&#160;</td>
          <td class="paramname"><em>next_transition</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a transition probability matrix. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">landing</td><td>Vector of probabilities of landing somewhere to begin the match. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">next_transition</td><td>Vector of probabilities of transitioning to the next match state. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Matrix of match probabilities just in terms of the transitions.</dd></dl>
<p>If next_transition is of length \(\ell-1\), then make an \(\ell \times \ell\) matrix M with the part of the match probability coming from the transitions. If \(a\) is next_transition and \(b\) is landing, </p><p class="formulaDsp">
\[ M_{i,j} := b_i (1-a_j) \prod_{k=i}^{j-1} a_k \]
</p>
<p> is the cumulative transition probability of having a match start at i and end at j. </p>

</div>
</div>
<a class="anchor" id="a6e16bc80240580a9eb7190baaf384427"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void linearham::ColVecMatCwise </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Ref&lt; Eigen::MatrixXd &gt;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function takes the coefficient-wise product of b and every column of A. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>Input vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>Input matrix. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">B</td><td>Output matrix. <p class="formulaDsp">
\[ B_{i,j} = b_i A_{i,j} \]
</p>
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a46be2fbc9551af01ae8b63b32f8347c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; int, int &gt; linearham::find_germline_start_end </td>
          <td>(</td>
          <td class="paramtype">YAML::Node&#160;</td>
          <td class="paramname"><em>root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>gname</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the indices corresponding to the start and end of the germline gene. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">root</td><td>A YAML root node. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">gname</td><td>The germline name. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 2-tuple containing the germline start and end indices. </dd></dl>

</div>
</div>
<a class="anchor" id="a0c0df111a675196fe2673a50a97c647a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; std::string &gt;, std::unordered_map&lt; std::string, int &gt; &gt; linearham::get_alphabet </td>
          <td>(</td>
          <td class="paramtype">YAML::Node&#160;</td>
          <td class="paramname"><em>root</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract the alphabet and alphabet-map from a YAML file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">root</td><td>A YAML root node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 2-tuple containing the alphabet and alphabet-map. </dd></dl>

</div>
</div>
<a class="anchor" id="a3808899cb2db8a3a231a11ec1459b249"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::regex, std::regex &gt; linearham::get_regex </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>gname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>alphabet</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the regex's that extract germline and insertion state labels. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">gname</td><td>The germline name. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alphabet</td><td>The alphabet. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A 2-tuple containing the regex's. </dd></dl>

</div>
</div>
<a class="anchor" id="a201f64bb15d6550afe76ec91bdd33fc3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">YAML::Node linearham::get_yaml_root </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>yaml_path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract the root node from a YAML file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">yaml_path</td><td>A string providing the path to a YAML file. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A YAML root node. </dd></dl>

</div>
</div>
<a class="anchor" id="ae7c3811ec2172f192ecd27e98d4c063d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool linearham::is_equal_string_vecs </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt;&#160;</td>
          <td class="paramname"><em>vec2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Do two string vectors contain the same elements? </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vec1</td><td>The vector to be tested for set equality. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">vec2</td><td>The (sorted) vector to be tested against for set equality. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If it is. </dd></dl>

</div>
</div>
<a class="anchor" id="ac49a32ee78052d4f748f7082f5001002"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; std::vector&lt; std::string &gt;, Eigen::VectorXd &gt; linearham::parse_string_prob_map </td>
          <td>(</td>
          <td class="paramtype">YAML::Node&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a YAML map from strings to probabilities. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">node</td><td>A YAML map node. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The map. </dd></dl>

</div>
</div>
<a class="anchor" id="a37d0ddb7c5498902f53fc09dc01b6881"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void linearham::RowVecMatCwise </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::RowVectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Ref&lt; Eigen::MatrixXd &gt;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function takes the coefficient-wise product of b and every row of A. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">b</td><td>Input vector. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>Input matrix. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">B</td><td>Output matrix. <p class="formulaDsp">
\[ B_{i,j} = b_j A_{i,j} \]
</p>
 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a56af488fc596ebb21cfa851f01469e5e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int linearham::ScaleMatrix </td>
          <td>(</td>
          <td class="paramtype">Eigen::Ref&lt; Eigen::MatrixXd &gt;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Scales a matrix by SCALE_FACTOR as many times as needed to bring at least one entry of the matrix above SCALE_THRESHOLD. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">m</td><td>Matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Number of times we multiplied by SCALE_FACTOR. </dd></dl>

</div>
</div>
<a class="anchor" id="a0b18787b2d615417a6b238bffd030998"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classlinearham_1_1Smooshable.html">Smooshable</a>, Eigen::MatrixXi &gt; linearham::Smoosh </td>
          <td>(</td>
          <td class="paramtype">const Smooshable &amp;&#160;</td>
          <td class="paramname"><em>s_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Smooshable &amp;&#160;</td>
          <td class="paramname"><em>s_b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Smoosh two smooshables! </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">s_a</td><td><a class="el" href="classlinearham_1_1Smooshable.html" title="Abstracts something that has probabilities associated with sequence start and stop points...">Smooshable</a> on the left. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">s_b</td><td><a class="el" href="classlinearham_1_1Smooshable.html" title="Abstracts something that has probabilities associated with sequence start and stop points...">Smooshable</a> on the right. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>(s_out, viterbi_idx) <code>s_out</code> is the smooshable resulting from smooshing s_a and s_b. <code>viterbi_idx</code> is the corresponding viterbi index.</dd></dl>
<p>When we smoosh two smooshables, they must have the same right and left flexes. Say this common value is n. The marginal probability is just a matrix product: </p><p class="formulaDsp">
\[ C_{i,k} := \sum_j A_{i,j} B_{j,k} \]
</p>
<p> because we are summing over the various ways to divide up the common segment between the left and right smooshable. The equivalent entry for the Viterbi sequence just has sum replaced with max. </p>

</div>
</div>
<a class="anchor" id="a6c1076d41d74aaa27dc93073ea10297e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void linearham::SubProductMatrix </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Ref&lt; Eigen::MatrixXd &gt;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function builds a matrix of sub-products. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">e</td><td>Input vector. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">A</td><td>Output matrix.</td></tr>
  </table>
  </dd>
</dl>
<p>If e is of length \(\ell\), then fill a \(\ell \times \ell\) matrix with the entries </p><p class="formulaDsp">
\[ A_{i,j} := \prod_{k=i}^{j} e_k \]
</p>
<p> Empty products are taken to be one. </p>

</div>
</div>
<a class="anchor" id="ab09d0b9aa0bbaed826474a8fc1d94092"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void linearham::VectorByIndices </td>
          <td>(</td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::MatrixXd &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Eigen::Ref&lt; const Eigen::VectorXi &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Eigen::Ref&lt; Eigen::VectorXd &gt;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function extracts a vector of entries of a matrix by row index. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">A</td><td>Input matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">a</td><td>Input vector of indices. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">b</td><td>Output vector.</td></tr>
  </table>
  </dd>
</dl>
<p>Assume \(A\) is \(m \times n\) and that \(a\) is a length-n vector of indices with entries from 0 to m-1. Then </p><p class="formulaDsp">
\[ b_i := A_{a_i, i}. \]
</p>
 
</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="a016030d1b11ad4876239174c980caccf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double linearham::EPS_PARSE = 1e-5</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a732264e6fba99037c44f896402b46f2b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double linearham::SCALE_FACTOR = pow(2, 256)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7a446f9faab6c4997544bb7e650e1d81"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double linearham::SCALE_THRESHOLD = (1.0 / <a class="el" href="namespacelinearham.html#a732264e6fba99037c44f896402b46f2b">SCALE_FACTOR</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Oct 24 2016 18:59:21 for linearham by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.8
</small></address>
</body>
</html>
